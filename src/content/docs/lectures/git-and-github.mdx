---
title: Git and GitHub Basics
description: Learn the basics of Git and GitHub for individual software development, including version control, repository management, and collaboration workflows.
draft: true
sidebar:
  order: 1
---

import Mermaid from "../../../components/Mermaid.astro";

Git and GitHub are indispensable tools in modern software development, used in nearly every significant project worldwide.

Although their core concepts are straightforward, their extensive features can sometimes feel overwhelming. Mastering these tools is essential for contributing to real-world software projects, and we will use them extensively throughout this course. To begin, we will explore Git and GitHub.

Initially, we will focus on using these tools as an individual developer. Later, we will delve into team-based collaboration workflows.

Git and GitHub are distinct tools, so we will examine each separately, starting with Git.

## What is Git?

Git is a version control system (VCS) designed to track changes to a set of files over time, allowing you to access and manage previous versions.

Using a VCS provides several key benefits:

- Reverting files to earlier versions.
- Comparing changes made over time.
- Synchronizing version history across multiple locations or collaborators.
- Identifying when and by whom changes were made.

While many VCSs exist, Git stands out in how it stores version history. Git represents version history as a series of snapshots of the project.

When you create a new version (known as a "commit"), Git saves a snapshot of all project files. This version history is essentially a stream of these snapshots.

Git optimizes storage by avoiding duplication. If a file remains unchanged, Git doesn't store a new copy; instead, it links to the previous version.

This stream of snapshots is stored in a Git repository (repo) located within the project directory:

![Git Repository Structure](https://git-scm.com/book/en/v2/images/snapshots.png)

Representing data as snapshots enables powerful features like branching, which we will explore later.

Another defining feature of Git is that it is a distributed VCS. Every location containing the version history is a complete mirror of the entire history, including every version, commit, and snapshot.

![Distributed Version Control](https://git-scm.com/book/en/v2/images/distributed.png)

This distributed nature has both advantages and challenges. A significant advantage is that every **clone** of the repository acts as a complete backup, increasing resilience to machine failures.

However, because every clone contains the full version history, care must be taken to prevent the snapshot streams from diverging.

For example, if developers A and B make commits in their respective clones simultaneously, they create different versions of the project's history. While these versions can be reconciled, the process can become difficult if the changes diverge significantly or conflict.

To address this, workflows are often used in Git projects with collaborators to ensure smooth reconciliation of work. We will discuss these workflows in detail later.

Finally, most Git operations are local, meaning you can work on a Git project without an internet connection.

Remote operations, such as synchronizing copies, require a network connection, but these are only necessary when explicitly executed.

We will soon explore how to use Git in practice.

## What is GitHub?

GitHub is a cloud-based hosting service for Git repositories, widely used to back up code and facilitate collaboration. Developers use Git commands to synchronize their code with a remote repository on GitHub as they make commits.

However, GitHub offers much more than just hosting. It provides a suite of tools that build upon hosted Git repositories to serve as a central hub for collaboration.

These tools, accessible through [GitHub's web client](https://github.com), include:

- Bug and issue tracking.
- Code review via **pull requests**.
- Task management.
- Continuous integration.
- Social features for developers.

GitHub is especially popular for team-based projects. A code project is hosted in a repository on GitHub, which acts as the central point for collaboration.

Each team member works on their own clone of the central GitHub repository. As they write code and make commits to their local clone, they push those commits back to the central repository. Other collaborators can then pull these commits from the central repository into their own clones, ensuring everyone stays up to date and can incorporate each other's changes.

Later in this course, we will explore GitHub's collaboration tools and workflows in greater detail, focusing on how they support team-based projects.

## Basic Workflow

Let's walk through a basic workflow for an individual developer using Git and GitHub, focusing on Git operations for making commits and synchronizing them.

Git is primarily a command-line tool, so we will emphasize the command-line version of Git operations. While I encourage you to become comfortable with the command-line interface to access Git's full functionality, you are free to use GUI Git clients like GitHub Desktop or GitKraken. Many code editors, such as VS Code, also include built-in Git clients.

If you plan to use GitKraken for this course, note that working with private repositories on GitHub requires GitKraken Pro. While GitKraken Pro is typically a paid service, students can access it for free through the GitHub Student Developer Pack, which also includes other useful tools.

### Installing Git

To use Git, you need to have a Git client installed on your development machine. The Pro Git book provides detailed installation instructions for various platforms. Here are some platform-specific notes:

- **Windows**: Install Git for Windows, which includes a command-line version of Git (called Git Bash) and a simple GUI.
- **Mac**: Use Homebrew to install Git with the following command `brew install git`.
- **Linux**: The command-line version of Git is typically pre-installed (including on the OSU ENGR servers).

### Configuring Git

If you're using Git for the first time on your development machine, you'll need to configure some basic settings before you can start. At a minimum, you must set your name and email address, which Git uses to identify you as the author of your commits. Use the following commands to configure these settings:

```shell
git config --global user.name "John Doe"
git config --global user.email "john.doe@example.com"
```

If you already have a GitHub account, you can use your GitHub email address here.

### Starting a Git Project

Now that Git is installed and configured, you're ready to start using it. There are two main ways to begin working on a Git-based project:

- Create a new repository from scratch--and eventually mirroring it on GitHub
- Clone an existing repository, such as one hosted on GitHub

We'll explore both methods in detail.

## Creating a Git Repository from Scratch

A Git repository is always tied to a directory, which aligns well with the practice of keeping code projects in their own dedicated directories. Git allows you to selectively manage which files and subdirectories are placed under version control.

To create a new Git repository, follow these steps:

```shell
mkdir my-project # Create a new project directory
cd my-project    # Navigate into the directory
git init         # Initialize a Git repository
```

This command creates an initial "database" to store your project's version history and other Git-related information. This database resides in a hidden `.git/` directory within your project folder.

Hidden directories (those starting with a `.`) are not visible by default, but you can view them using:

- **Unix Terminals**: `ls -a`
- **Windows Command Prompt**: `dir /a:hd`

:::caution
Avoid manually modifying anything inside the `.git/` directory. Always use Git commands to interact with this data. Manual changes can corrupt your repository. Typically, you only need to check for the existence of the `.git/` directory to confirm that Git is initialized.
:::

### States in a Git Repository

Files in a Git repository can exist in different states:

1. **Not Staged for Commit**:
    - **untracked**: the file is not tracked by Git and is not included in the version history.
    - **modified**: the file is tracked by Git, but its contents have changed since the last commit.
    - **deleted**: the file is tracked by Git, but it has been deleted from the working directory.
2. **Staged**: The file is marked to be included in the next commit. It can be in state **new file**, **modified**, or **deleted**, respectively.
3. **Committed**: The file's changes are saved in the repository and doesn't have any changes since the last commit.

This means that before a file can be committed, it must be staged. 

:::note[Ignoring Files?]
It's also worth noting that files can be in the **ignored** state (intentionally excluded from version control). You can specify this by creating a `.gitignore` file, as we'll see later.
:::

In general, we can think of a Git project as having three separate parts: the working directory, the staging area, and the repository itself (i.e. the `.git/` directory).

The working directory is where your files live. This is where you write code, edit files, and make changes. The staging area is a temporary holding area for files that are ready to be committed. The repository is where the version history of your project is stored.

In particular, as we work on a project, we may make changes to many files at once. At some point, we may decide that we are ready to commit some of those changes but not ready to commit others. This is what the staging area allows us to do. The working directory, the staging area, and the Git repository interact like this:

<Mermaid title="Git Workflow" showForPrint="true">
```
sequenceDiagram
  .git Directory ->> Working Directory: Checkout the latest commit
  Working Directory ->> Staging Area: Stage files
  Staging Area ->> .git Directory: Commit changes
```
</Mermaid>

Let's run through an example of this workflow.

### Staging Files

With the repository initialized, you can now add files to version control. Start by creating two files in your project directory, `cat.js` and `dog.js`, and add some content to them:

```shell
echo 'console.log("Meow!");' > cat.js
echo 'console.log("Woof!");' > dog.js
```

Next, check the current state of your working directory using the `git status` command:

```shell
git status
```

The output will look something like this:

```text
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        cat.js
        dog.js

nothing added to commit but untracked files present (use "git add" to track)
```

The "untracked files" section indicates that Git sees these files but is not yet tracking them. To start tracking the files, use the `git add` command:

```shell
git add cat.js dog.js
```

Alternatively, to track all files, you can use:

```shell
git add .
```

Run `git status` again, and you'll see the updated output:

```text
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   cat.js
        new file:   dog.js
```

### Committing Files

Now the files are staged for a commit. To save this snapshot, use the `git commit` command:

```shell
git commit
```

Git will open a text editor for you to write a commit message. Enter a brief description, such as:

```text
Add cat and dog sounds
```

Save and close the editor to complete the commit. If you check the status again, you'll see:

```text
nothing to commit, working tree clean
```

Alternatively, you can skip the editor by using the `-m` option to specify the commit message directly:

```shell
git commit -m "Add cat and dog sounds"
```

:::tip
We can use `git config` to set the editor Git opens for us when we run `git commit`. For example, if we want Git to use `vim` as the default editor, we could run this command (you can replace `vim` with the command-line command for your favorite editor):

```shell
git config --system core.editor vim
```
:::

To view the commit history, use:

```shell
git log
```

The output will include details like the commit hash, author, timestamp, and message:

```text
commit c4f570c3ce30fcf50f8f8a7736306030667e9337 (HEAD -> master)
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:04:30 2025 -0800

    Add cat and dog sounds
```

The ong hexadecimal value associated with the commit is known as the commit hash. Here, the commit hash is:

```text
c4f570c3ce30fcf50f8f8a7736306030667e9337
```

There are a couple things to know about the commit hash:

- The commit hash is a checksum computed based on the contents of the commit itself. This means that the commit hash verifies the integrity of the commit it's associated with.
- The commit hash also serves as a unique identifier for the commit it's associated with. When we need to refer to a specific commit in certain Git operations, we will typically do so using the hash of that commit.

### Reviewing Changes with `git diff`

Now, let's modify the files. Update `cat.js` and `dog.js` as follows:

```js
// cat.js
console.log("Purr...");
```

```js
// dog.js
console.log("Woof!");
console.log("Bark!");
```

Before committing these changes, check the status again:

```shell
git status
```

The output will indicate "changes not staged for commit." 

```text
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   cat.js
        modified:   dog.js

no changes added to commit (use "git add" and/or "git commit -a")
```

To see the exact changes, use the `git diff` command:

```shell
git diff
```

This will display a unified diff showing the differences between the current working directory and the last commit:

```diff
diff --git a/cat.js b/cat.js
index ab949dc..45819c5 100644
--- a/cat.js
+++ b/cat.js
@@ -1 +1 @@
-console.log("Meow!");
+console.log("Purr...");
diff --git a/dog.js b/dog.js
index 9260ad6..5b62dbb 100644
--- a/dog.js
+++ b/dog.js
@@ -1 +1,2 @@
 console.log("Woof!");
+console.log("Bark!");
```

Git uses a specific format called unified format to produce diffs. This format can be a bit difficult to read at first because it's designed for both human and machine consumption. Here's what you should know about Git diffs:

A diff will represent each file under version control that has been modified since the last commit. The changes for each file are indicated by a 4-line header, such as:

```diff
diff --git a/dog.js b/dog.js
index 9260ad6..5b62dbb 100644
--- a/dog.js
+++ b/dog.js
```

The most important part of this header is the file name, in this case, `dog.js`.

Following the header, you'll find one or more change hunks detailing the specific modifications made to the file. Each hunk starts with a line that specifies the line numbers involved in the change, like this:

```diff
@@ -1 +1,2 @@
```

The range information indicates the changes starting at line 1 of cat.js in the last commit (represented by the `-` sign) and spanning from line 1 to line 2 in the current working directory (represented by the `+` sign).


Finally, the hunk contains the actual changes, represented by three types of lines (note that the coloring may vary depending on the Git implementation):

- Lines starting with a `-` indicate a deletion, meaning the line existed in the last commit but is no longer present in the working directory.
- Lines starting with a `+` indicate an addition, meaning the line is present in the current working directory but was not in the last commit.
- Lines that don't start with either `-` or `+` are contextual lines, providing surrounding context for the changes.

For example, the change hunk for `dog.js` shows the two lines added since the last commit, along with a contextual line:

```diff
 console.log("Woof!");
+console.log("Bark!");
```

In the change hunk for `cat.js`, a modified line is represented as both a deletion and an addition:

```diff
-console.log("Meow!");
+console.log("Purr...");
```

### Staging and Committing Changes

When you made your changes, you should stage and commit again. You can do it piecewise. For example, to stage only `dog.js`, run:

```shell
git add dog.js
```

Check the status again:

```text
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   dog.js

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   cat.js
```

Now, commit the staged changes:

```shell
git commit -m "Make dog bark too"
```

You can repeat this process for `cat.js` or any other files. Use `git log` to verify the commit history and `git status` to check the working directory's state.

## Mirroring a Local Git Repo on GitHub

At the moment, the repo we've been working with lives only on our development machine. There are no remote copies of it. Let's work on changing that by mirroring our repo on GitHub.

Start out by navigating to [github.com](https://github.com/) in your web browser. If you haven't done so yet, you'll need to sign up for a GitHub account and make sure you're logged in.

Once you're logged into GitHub, there are several ways to create a new repo there.

Go ahead and create a new repo on GitHub. GitHub will ask you for some information about the repo you're creating. Since we're starting with an existing repo (the one on our development machine), we'll have to be careful to set up our new GitHub repo correctly. Specifically, on the “create a new repository” page on GitHub, we want to specify the following settings so that no new files are created in the repo on GitHub:

- Repository name: Typically, the repository name should match the name of the project directory, which in this case is `my-project`.
- Description: You can set this if you want.
- Public/private: You can choose either. A public repo will be visible to anyone. A private repository will be visible only to you (until you give other developers access).
- Add a README file: leave unchecked
- Add .gitignore: None
- Choose a license: None

After you create the repository with the above settings, GitHub will navigate you to a page representing your new repo.

We're almost ready to push the commits from our development machine to the new repo we just created on GitHub. Before we do this, though, we need to decide how our development machine will communicate with GitHub. There are two options: SSH and HTTPS.

At the top of the page representing your new repo on GitHub, you should see a box with buttons that allow you to toggle between these two modes of communication.

Either communication option will require some setup with GitHub and on your development machine. We'll briefly explore this setup below.

### Creating a Personal Access Token (PAT) 

If we choose to communicate with GitHub using HTTPS, Git will prompt us to authenticate ourselves with GitHub when we execute a Git operation that communicates with GitHub.

Importantly, GitHub does not support simple password-based authentication. Instead, if we want to use HTTPS communication, we'll have to generate a GitHub personal access token (PAT). This is a special string that acts as an alternative to a password and has specific permissions built into it.

To use HTTPS communication, you'll need to start out by following the instructions in the [GitHub documentation for creating a PAT](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens). These instructions give you a couple options about what kind of personal access token to create and what permissions to associate with the token. For this course, I'd recommend the following settings:

- Type: personal access token (classic)
- Scopes: repo

The personal access token you create will be a long string something like. Make sure you copy this string and keep it somewhere secure. You should treat your personal access token like you would treat a password.

Have this token ready. We'll use it in a minute when we want to push commits from our development machine to GitHub. In some environments, you may be prompted for your personal access token every time you want to use Git to communicate with GitHub. In other environments, Git will remember your personal access token after the first time you use it.

### Setting up SSH Keys

In order to be able to communicate with GitHub via SSH, we'll need to create an SSH key and register it with GitHub. An SSH key is an authentication credential that will be exchanged with GitHub when we connect with it via SSH. It serves as an alternative to a username and password. In fact, even though an SSH key typically has a password associated with it, we'll usually only need to enter that password once, and thus an SSH key can be used to perform “passwordless” authentication.

There are several steps to follow to set up an SSH key and register it with GitHub. Follow these steps on your development machine:

- First, check to see if you [already have existing SSH keys](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys).
- If you don't already have an existing SSH key, [generate a new one and set your machine up to use it](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent).
*   Next, [register your SSH key with GitHub](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account).
*   If you want to, [test your SSH connection with GitHub](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/testing-your-ssh-connection).

### Setting our GitHub Repo as a Remote

Once we're ready to communicate with GitHub using either HTTPS or SSH, we can now push the repository data from our development machine to GitHub.

On the new repository page on GitHub, select either HTTPS or SSH, depending on which form of communication you want to use, and then copy the corresponding URL, which should look something like one of these two:

```shell
https://github.com/<username>/<repository>.git # HTTPS
git@github.com:<username>/<repository>.git`    # SSH
```

In order to connect the local repository on our development machine with the one we just created on GitHub, we'll need to register the GitHub repo as a remote within our local repo. A Git remote is simply a repo that lives somewhere else that we want to keep synchronized with our local repo.

To do this, we can use Git's `remote` operation, which allows us to view and manipulate remotes. We'll register our GitHub repo as a remote named `origin`, indicating that it will be the default remote we want to synchronize with. You can do this by running the following command, pasting in either the HTTPS URL or the SSH URL, depending on which form of communication you want to use:

```shell
git remote add origin <HTTPS_or_SSH_URL>
```

You can verify that the remote was correctly set up by running this command, which prints out all the remotes associated with a local repo along with their URLs:

```shell
git remote -v
```

This should print out a message that looks something like this (with your own HTTPS or SSH URL, of course):

```text
origin  https://github.com/<username>/<repository>.git (fetch)
origin  https://github.com/<username>/<repository>.git (push)
```

Next, we'll make sure our local repository is using the correct default branch name. By convention, the name `main` should be used for the default branch:

```shell
git branch -M main
```

Finally, we can use Git's `push` operation to send the commit history from our local repo to the remote repo on GitHub:

```shell
git push -u origin main
```

This command specifically tells Git to send the changes from the current branch on our local repo (whose name we just set to `main`) to the branch named `main` on the remote named `origin`. The `-u` option makes a permanent connection between the local branch and the remote branch so that in the future, we'll be able to execute the `git push` command (as well as other commands, like `git pull`) without arguments.

If the `push` operation successfully executes, the files you committed to your local repo should be visible on GitHub if you refresh the GitHub repo page in your browser.

Take a minute to explore the repo page on GitHub to see what information is available there. For example, you should be able to view your project's entire commit history by clicking the commit history link in the GitHub repo.

We'll explore other features available through this repository page on GitHub as we move through the course.

## Starting with an Existing Repo on GitHub

The other main way we might begin working on a Git project is to start with an existing remote repo, e.g. one on GitHub.

In order to do this, we'll need to make a working copy of the remote repo on our development machine. In git terminology, this is called making a **clone** of the remote repo.

To see how to do this, let's actually make a clone of the repo we created and mirrored on GitHub just above.

If you want to do this on the same development machine where you created the original repo, you'll need to start out by navigating to a different directory on that machine. Alternatively, you can move to a different development machine for now (e.g. by connecting through `ssh` to one of the ENGR servers).

We'll refer to whatever location you're going to make a clone of the repo at as “location #2”. We'll refer to the original location of the repo as “location #1”.

On the home page for your project on GitHub, you should see a green “Code” button. If you click that button, it'll open a dropdown with options for cloning the repo (along with other options for working with the code).

In the “clone” section of that dropdown, make sure you select the form of communication you want to use to clone the repo, either HTTPS or SSH, and copy the URL presented in the dropdown for that form of communication (it should be the same URL we used when we set up the remote above).

At location #2, run this command to clone the repo, pasting in your HTTPS or SSH URL:

```shell
git clone <HTTPS_or_SSH_URL>
```

When this command completes, you'll have a clone of the repo at location #2. This clone will live in a directory whose name matches the name of the repo on GitHub (i.e. `my-project/`), and it will contain the project's complete version history.

If you list the contents of that directory and look at the files, you'll see that they match the most recent commit we made at location #1 (remember, we didn't commit the modification we made to `cat.js`).

Importantly, because we created this local repo by cloning a remote repo, Git will automatically set up a connection to the remote repo, giving it the name `origin` like we did when we manually set up a remote at location #1 above. You can see this if you navigate into the new repo and run `git remote -v`. Like we did manually above, Git will set up the branch `main` of the local repo to track the branch `main` of `origin`, so we can run `git push` and `git pull` without arguments.

We can now work on this cloned repo at location #2 in exactly the same way we worked on the original repo at location #1. If we do continue to work in both locations, there will be a few extra considerations we'll need to make. We'll cover those next.

## Working on a Git Repo in Two Different Locations

If we want to work on two different instances of the same Git repo (e.g. on two different machines), we'll have to take a bit of extra care to make sure our commit history stays consistent between the two repos.

In this case, we have two different clones of a repo (in location #1 and location #2) that are both connected to the same repo on GitHub.

Let's make a new commit at location #2 and see how to deal with that commit at location #1. Specifically, let's make and commit the following modification (adding one more “woof”) at location #2:

```js
// dog.js
console.log("Woof!");
console.log("Bark!");
console.log("Bark!");
console.log("Bark!");
```

Once that change is committed, let's push it to the repo on GitHub by running `git push`.

Now, let's say we want to go back to work at location #1. We know we made changes to the code at location #2 and pushed those changes to GitHub, so before we start to make changes at location #1, we need to make sure we have the most recent version of the code there by synchronizing the repo at location #1 with the one on GitHub. We can do this with Git's `pull` operation:

```shell
git pull
```

This will “pull” all of the commits from GitHub into the repo at location #1 and incorporate those commits into the working directory.

A good rule of thumb when working on two different instances of the same Git repo is this:**Before you start working in a different location, pull all changes from GitHub to make sure you're working on the most up-to-date version of the code.**

Following this rule of thumb will help to prevent conflicts from being introduced into the version history.

Let's keep going a bit to see what might happen when we don't follow this rule of thumb.

### Dealing with Merge Conflicts

Let's remain at location #1 for a minute. Recall when we stopped working at location 1, we had actually made a modification to `cat.js` we didn't yet commit. You can run `git diff` there to see it:

```diff
diff --git a/cat.js b/cat.js
index ab949dc..45819c5 100644
--- a/cat.js
+++ b/cat.js
@@ -1 +1 @@
-console.log("Meow!");
+console.log("Purr...");
```

Let's commit and push this modification at location #1:

```shell
git add cat.js
git commit
git push
```

Now let's move back to location #2 and pretend we've forgotten to follow our rule of thumb about pulling before we start working there. 

Specifically, before we pull at location #2, let's make a change to `cat.js` there, adding a new line to make the cat hiss (the first line of `cat.js` should not reflect the change we committed and pushed from location #1):

```js
// cat.js
console.log("Meow!");
console.log("Hiss!");
```

Now, let's say we remember at this point that we forgot to pull from GitHub before starting to work again at location #2, and we go ahead and run `git pull` there. If we do that, git will report an error to us:

```text
error: Your local changes to the following files would be overwritten by merge:
	cat.js
Please commit your changes or stash them before you merge.
Aborting
```

As the error message tells us, we have two different options to handle this situation: commit our changes or stash them. One of these options will be fairly painless, and one will lead to some trouble. Let's briefly look at the painless option first, then we'll explore the one that will lead to trouble.

The painless option here is to stash our changes. The term “stash” here has a specific meaning. In particular, Git has a `stash` operation we can use to record the current, modified state of the working directory and then roll the working directory back to the most recent commit:

```shell
git stash
```

If we run `git stash` at location #2, and look at our code, we'll see it now reflects the state it was in when we last committed at location #2. If we run `git status` at this point, it will report that our working directory is clean (i.e. it has no modifications). We could also see a record of our stashed changes if we wanted to:

```shell
git stash list
```

At this point, we could run `git pull` at location #2 if we wanted to, and it would successfully pull the most recent commits from GitHub. Then, we could reapply the changes we stashed and keep going from there. However, let's not do this yet. Instead, let's explore the more painful option we could have taken when we first tried to pull changes from GitHub.

Without pulling, let's reapply the changes we stashed at location #2:

```shell
git stash pop
```

Note that the subcommand here is called `pop` because Git's stash functionality stores stashed changes in a stack. Each time we run `git stash`, it pushes a new set of changes on top of the stash stack. Running `git stash pop` pops the changes from the top of the stash stack and reapplies them.

Now, let's commit those changes:

```shell
git add cat.js
git commit -m "Cat hisses"
```

If we go one step further now and try to push the new commit to GitHub, we'll see an error message that looks something like this:

```
To https://github.com/<username>/my-project.git
 ! [rejected]        main -> main (non-fast-forward)
error: failed to push some refs to 'https://github.com/adulbrich/my-project.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. If you want to integrate the remote changes,
hint: use 'git pull' before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

The error message is slightly misleading in this particular situation. The real issue here is that we have now created two different versions of the commit history, one that lives at location #2 and another that lives both on GitHub and at location #1. We can see the two different commit histories if we run `git log` at both location #1 and location #2.

If we try to run `git pull` at location #2 as suggested by the error message above, we'll get another error message that's more accurate:

```text
hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint:
hint:   git config pull.rebase false  # merge
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint:
hint: You can replace "git config" with "git config --global" to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
fatal: Need to specify how to reconcile divergent branches.
```

Again, we have a couple different options here for how to deal with the issue. We'll try to resolve it by merging the two commit histories together (we'll discuss rebase later):

```shell
git config pull.rebase false # this sets the pull to merge
git pull
```

Alternatively, you can merge explicitly:

```shell
git merge origin/main
```

This command will specifically try to take the commit history from the `main` branch of the `origin` remote and join it together with the local `main` branch at location #2. Unfortunately, in both cases, Git will report a conflict:

```text
Auto-merging cat.js
CONFLICT (content): Merge conflict in cat.js
Automatic merge failed; fix conflicts and then commit the result.
```

Trying to run these again will not help:

```text
error: Merging is not possible because you have unmerged files.
hint: Fix them up in the work tree, and then use 'git add/rm <file>'
hint: as appropriate to mark resolution and make a commit.
fatal: Exiting because of an unresolved conflict.
```

The underlying problem here is that the latest commit in each of the two different commit histories here have different versions of the same line of code. 

This is known as a conflict, and it is preventing Git from being able to automatically merge the two commit histories together (which it can normally do if there are no conflicts). This means we must manually resolve the conflict to complete the merge.

If we actually look at the contents of `cat.js` at location #2 at this point, we will see that Git has modified the file to highlight the conflict. Specifically, at location #2, `cat.js` currently looks like this:

```js
<<<<<<< HEAD
console.log("Meow!");
console.log("Hiss!");
=======
console.log("Purr...");
>>>>>>> 1817ae01cb389bd5f48282e8b09f56a84e7f474e
```

The syntax here may be somewhat cumbersome, but it's presenting us with the two different sides of the conflict. The first version (between the `<<<<<<<` and the `=======`) is the local version, and the second version (between the `=======` and the `>>>>>>>`) is the version from `origin/main`.

We need to edit the file to indicate how we want to resolve the conflict. We can do this however we want. For example, we could delete everything except the local version of the code to resolve the conflict in favor of the local commit history, or we could delete everything except the remote version of the code to resolve the conflict in favor of the remote commit history. Or, we could create a hybrid of the two versions of the code, with some pieces from the local version and others from the remote version.

Many visual code editors have built-in tools to present this conflict to us in a more intuitive way. For example, in VS Code, we could use the built-in “merge editor” to view the conflict. Other visual editors have similar tools, and we can use them to click and type our way through the conflict.

However we do it, let's resolve the merge conflict as a hybrid between the two version histories, taking the line of `cat.js` from the remote history and all lines from the local history:

```js
// cat.js
console.log("Meow!")
console.log("Hiss!")
console.log("Purr...")
```

To complete the conflict resolution, we can mark the conflict as resolved by running `git add` and then running `git commit` to finalize the merge at location #2:

```shell
git add cat.js
git commit
```

Here, when we run `git commit`, we will see that Git will give us the start of a commit message. We can add to this if we want.

Now, we should be able to successfully push everything from location #2 to GitHub:

```shell
git push
```

And, just for good measure, we can go back to location #1 to make sure we can pull the merged commit history there:

```shell
git pull
```

Now, if we use `git log` to look at the commit histories at both locations, we should see that they are again the same. The commit history on GitHub should also be the same.

Hopefully, this is the last time you ever have to worry about merge conflicts, but it probably won't be. In any case, if you do run into a merge conflict again, you should now have some idea about how to approach it.

However, this should all make the importance of our rule of thumb above more clear. Let's repeat it again here for emphasis:

> Before you start working in a different location, `pull` all changes from GitHub to make sure you're working on the most up-to-date version of the code.

## Cleaning Up Your Commit History

One of the most important things to know about Git is that it's designed to help you keep a clean, organized commit history. This means that you should try to make sure that each commit you make represents a single, coherent change to your project. This will make it easier for you to understand your project's history and to collaborate with other developers. Employers might also look at your Git history to see how you work, so it's a good idea to keep it clean.

One of the most common ways to clean up your commit history is to use Git's `rebase` operation. This operation allows you to rewrite your commit history by combining, splitting, or reordering commits.

Let's start with a `git log` of our work so far:

```text
commit da7e2e995e86828a46779fb3ae2c06efa9e43ea3 (HEAD -> main, origin/main)
Merge: 673e6b8 1817ae0
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:51:26 2025 -0800

    Merge branch 'main' of https://github.com/adulbrich/my-project

commit 673e6b830f9adb1cbce9aa200afe9dd40dfc0a4b
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:38:06 2025 -0800

    Cat hisses

commit 1817ae01cb389bd5f48282e8b09f56a84e7f474e
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:35:05 2025 -0800

    Cat purrs now

commit 3b0a84cd3767da40a9e9ed8d51722d589871a443
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:06:39 2025 -0800

    Make dog bark too

commit c4f570c3ce30fcf50f8f8a7736306030667e9337
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:04:30 2025 -0800

    Add cat and dog sounds
```

This commit history is a bit messy. We have a merge commit that doesn't really represent a change to our project, and we have a couple commits that are related to the same change. Let's clean this up by using `rebase`.

The first thing we'll do is run `git rebase -i HEAD~3`. This command tells Git to start an interactive rebase that will include the last four commits. When we run this command, Git will open an editor with a list of the last three commits in our commit history:

```text
pick 3b0a84c Make dog bark too
pick 673e6b8 Cat hisses
pick 1817ae0 Cat purrs now

# Rebase c4f570c..da7e2e9 onto c4f570c (3 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup [-C | -c] <commit> = like "squash" but keep only the previous
#                    commit's log message, unless -C is used, in which case
#                    keep only this commit's message; -c is same as -C but
#                    opens the editor
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
#         create a merge commit using the original merge commit's
#         message (or the oneline, if no original merge commit was
#         specified); use -c <commit> to reword the commit message
# u, update-ref <ref> = track a placeholder for the <ref> to be updated
#                       to this position in the new commits. The <ref> is
#                       updated at the end of the rebase
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
```

Notice that by design, the merge commit does not show up. When you use git rebase, it:

- Temporarily sets aside your commits
- Updates your branch to the latest version of the target branch
- Reapplies your commits one by one on top of that updated base

If we wanted to include our initial commit, we could have used `git rebase -i --root` instead.

For now, let's clean up our commit history by squashing the last two commits into the first one. To do this, we'll change the file to look like this:

```text
pick 3b0a84c Make dog bark too
squash 673e6b8 Cat hisses
squash 1817ae0 Cat purrs now
```

When we save and close the file, Git will reapply the commits in the order we specified. It will then open an editor to allow us to create a new commit message that will represent the squashed commits. We can keep the default message or change it to something more descriptive.

After we save and close the commit message, Git will have rewritten our commit history. We can verify this by running `git log` again:

```text
commit 600f9a073e36a932b870c9886229d02b2376ae21 (HEAD -> main)
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:06:39 2025 -0800

    dog barks too, cat hisses and purrs

commit c4f570c3ce30fcf50f8f8a7736306030667e9337
Author: Alexander Ulbrich <adulbrich@users.noreply.github.com>
Date:   Thu Feb 27 21:04:30 2025

    Add cat and dog sounds
```

Depending on the situation, you might also want to use `rebase` to reorder commits, split commits, or even remove commits. You can do all of these things with the interactive rebase tool.

If there are conflicts, you'll have to resolve them first before continuing. There are other `git rebase` flags such as `--continue`, `--abort`, and `--skip` that you can use to manage the rebase process. Read the messages that Git gives you during the rebase process to understand what you need to do.

Once the rebase has been done on your local, you need to update the remote. Because you are rewriting history, a regular `git push` will be rejected. To overwrite the remote history but check that nobody else has pushed changes in the meantime, you can use:

```shell
git push --force-with-lease
```

:::caution[Rewriting History in a Shared Repo]
When collaborating with others, as we'll explore later in the course, it's considered best practice to **avoid** rewriting history. Doing so can create issues for teammates working on the same branch.

If you're working on a branch that only you are using, rewriting history with `rebase` is generally safe. However, if you find it absolutely necessary to rewrite the history of the main branch, make sure to coordinate with your team beforehand to avoid conflicts.
:::

## Additional Readings and Resources

One of the nicest kinds of resources you can have as you're continuing to learn how to use Git and GitHub is a Git cheat sheet, which just provides a basic summary of some of the most important Git commands. You can find a couple nice Git cheat sheets at these locations:

- [GitHub's Git Cheat Sheet](https://education.github.com/git-cheat-sheet-education.pdf)
- [Atlassian's Git Cheat Sheet](https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet)

In addition, Julia Evans does a great job at explaining Git's quirks in her blog posts, such as:

- [Confusing git terminology](https://jvns.ca/blog/2023/11/01/confusing-git-terminology/)
- [git branches: intuition & reality](https://jvns.ca/blog/2023/11/23/branches-intuition-reality/)

And of course, there's the [Pro Git book](https://git-scm.com/book/en/v2), which is a great resource for learning more about Git. Most visuals on this page are sourced from the book. Check out Chapters 1 and 2 of the book for a more in-depth introduction to Git.
