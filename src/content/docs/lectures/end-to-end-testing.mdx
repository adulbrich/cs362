---
title: End-to-End Testing
description: TODO
draft: true
sidebar:
  order: 7
---

End-to-end testing is crucial for verifying that complete software systems function correctly from the user's perspective. Let me explain this important testing approach in detail.

## What are End-to-End Tests?

While unit tests validate individual code components and integration tests verify how small groups of components work together, **end-to-end (E2E) tests** evaluate entire software systems as they would function in production environments.

E2E tests run a complete application (or a substantial portion of it) in conditions that closely resemble real-world usage, automatically interacting with the system to validate its behavior across interconnected components.

### How E2E Tests Work

For applications with graphical interfaces, E2E testing employs automated processes that mimic human interactions—clicking buttons, entering text, scrolling through pages—and verifies that each action produces the expected outcome.

A key characteristic of E2E testing is its minimal use of test doubles. Unlike smaller test types, E2E tests typically interact with all real dependencies, including those involving network communication or other resource-intensive operations that would normally be mocked in unit or integration tests.

### Cost vs. Benefit Considerations

Due to their comprehensive nature, E2E tests are:

- More expensive to develop and maintain
- Slower to execute than other test types
- Typically fewer in number within a test suite

For these reasons, E2E tests are often strategically focused on validating critical user workflows or key business processes rather than attempting to cover every possible interaction.

### E2E Testing for Web Applications

In our course, we'll explore E2E testing using [Playwright](https://playwright.dev/), a powerful tool for automating browser-based testing. Playwright will:

1. Launch real browsers (Chromium-based, Firefox, WebKit-based)
2. Programmatically interact with your web application
3. Execute predefined test scenarios
4. Verify application responses using assertions
5. Provide detailed reports of test outcomes

Playwright supports not only JavaScript, but also TypeScript, Python, Java, and C#, making it a *versatile* choice for E2E testing across various programming languages. It is cross-platform (Windows, macOS, Linux) and can be used for both web and mobile applications.

This approach allows us to validate complete user journeys through our applications, ensuring they function correctly from start to finish in realistic conditions.

There are other popular E2E testing frameworks, such as [WebDriverIO](https://webdriver.io/), [Cypress](https://www.cypress.io/), and [Selenium](https://www.selenium.dev/), but Playwright stands out for its speed, reliability, and ease of use.

Playwright and WebDriverIO integrate nicely with Vitest.

## Running an Application for E2E Testing 

Before diving into how to use Playwright for end-to-end testing, it's important to understand how to properly configure your application for testing with this tool.

### Setting Up Your Application for E2E Testing

Playwright is designed for end-to-end testing web applications and expects the application to be running on a server during tests. This matches the production environment where web applications operate through servers rather than as local files.

### Starting Your Application Server

For Playwright to interact with your web application, your application server needs to be running. That means you need to first build then preview your build. All frameworks operate a little differently, but the general idea is the same.

For example, if you're using a framework like React, Vue, or Angular, you would typically run a build command like (refer to your framework's documentation):

```bash
npm run build
```

Then you would start a local server to serve the built files. This is often done with commands such as:

```bash
npm run preview
npm run start
```

Check your `package.json` file for the exact commands to build and start your server. 

### Testing Static Web Applications

If your application consists solely of HTML, CSS, and client-side JavaScript, you can use a simple static server to serve your files. We've done that in previous lecture with the `http-server` package (but others exist, such as `serve`).

### Accessing Your Application

To test your web application, Playwright needs the URL where your application is running. Most development or preview servers will display the application URL when starting up (typically something like http://localhost:3000).

In all Playwright test scenarios, you'll need to know this URL to navigate to your application at the beginning of your tests.

### Best Practices

When setting up your testing workflow:

1. Ensure your application server starts reliably
2. Configure a consistent port for easier test automation
3. Consider using a dedicated test environment or database
4. Document the startup procedure for other team members

This server-based setup ensures that your Playwright tests interact with your application in a manner that closely resembles how real users would experience it in production.

Note that Playwright allows you to configure these steps in your test scripts, so you can automate the process of starting your server and running your tests together. This is particularly useful for continuous integration (CI) environments where you want to run tests automatically whenever code changes are made.

## Installing and Setting Up Playwright

To [install Playwright](https://playwright.dev/docs/intro), you can use the following command:

```bash
npm init playwright@latest
```

It will ask you a series of questions to set up your project. You can choose the default options or customize them according to your needs. It also creates a `playwright.config.ts` file, which contains the configuration for your Playwright tests.

If your project uses TypeScript, using Playwright with TypeScript is straightforward. The Playwright package includes TypeScript definitions, so you can write your tests in TypeScript without any additional setup.

Playwright expects your tests to be in a specific folder. By default, it will look for tests in the `tests` folder, which might be used by another testing framework. It will then propose to create a new folder called `e2e` for your Playwright tests. 

Playwright also provides a default GitHub Actions workflow file to run your tests in a CI environment. We'll discuss CI/CD and GitHub Actions in a later lecture, but for now, you can ignore this file if you're not using GitHub Actions.

Finally you have the option to install the three main browser engines that Playwright supports: Chromium, Firefox, and WebKit. These are the browser engines that Playwright will use to run your tests. You can choose to install all three or just the ones you need. 

You can [change the test configuration](https://playwright.dev/docs/test-configuration) by modifying the `playwright.config.ts` file.

:::caution[ENGR Servers]
I haven't tested Playwright on the ENGR servers yet, but I do not expect it to work right away (if at all). Please use an alternative environment for now (local is preferred).
:::

To run Playwright tests, you can use the following command:

```bash
npx playwright test
```

This command will run all the tests in the `tests` folder (or the folder you specified during setup) and generate a report of the test results.

You can use the [Playwright UI Mode](https://playwright.dev/docs/test-ui-mode) with:

```bash
npx playwright test --ui
```

The UI mode is particularly helpful as it provides a visual interface where you can:

- See all your test files
- Run tests individually or in groups
- View test results with screenshots
- Debug tests interactively with time-travel debugging

You can add one or more scripts to your `package.json` file to make it easier to run your tests. For example, you can add the following scripts:

```json
{
  "scripts": {
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

This way, you can differentiate between different test frameworks and run them separately. 

If you want to automatically setup a development server before running your tests, you can add the [`webserver` field](https://playwright.dev/docs/test-webserver) to your `playwright.config.ts` file. This will allow Playwright to start your server before running the tests and stop it afterwards.

```ts
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  // ... other config options
  webServer: {
    command: 'npm run preview', // command you use to start your server
    url: 'http://localhost:4173/',
  },
});
```

Note that by default Playwright favors TypeScript (`.ts`) for files. TypeScript is a superset of JavaScript that adds static typing, which can help catch errors at compile time rather than runtime. This is particularly useful for larger projects where type safety can prevent many common bugs.

## Writing Our First Playwright Test

Up to now, we've used the `.test.` file extension for our tests. Playwright uses the `.spec.` file extension in their documentation (also supported by Vitest, as you might remember). It emphasizes that tests are **specifications** of how the application should behave, not just arbitrary checks. Using `.spec.` reflects a mindset rooted in **Behavior-Driven Development (BDD)**, where tests are written to describe the behavior of the system in a human-readable, declarative way.

Let's write our first Playwright test. Create a new file called `todo.spec.js` in the `tests` folder. 

```js
// tests/todo.spec.js
import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => {
	await page.goto('http://localhost:4173/');

	// Expect a title "to contain" a substring.
	await expect(page).toHaveTitle(/Todo App/);
});
```

There's a lot going on in this test, so let's break it down:

- Similarly to other test frameworks such as Vitest,, the `import` statement imports the `test` and `expect` functions from the Playwright library. These functions are used to define tests and make assertions, respectively.
- The `test` function defines a test case. It takes two arguments: a string describing the test and an asynchronous function that contains the test logic.
- The function passed to `test` is asynchronous because the framework interacts with web browsers, which involves inherently asynchronous operations such as navigating to pages, interacting with elements, and waiting for network requests or DOM changes.
- The `page` object is a built-in test fixture provided by Playwright. It represents a new browser page that is created for each test. 
- The `page.goto` method navigates to the specified URL. In this case, it opens the URL of our application.
- The `expect` function is used to make assertions about the state of the application. In this case, it checks that the page title contains the substring "Todo App". This is a common way to verify that the correct page has loaded and that the application is functioning as expected.
- The `toHaveTitle` method is a Playwright-specific assertion that checks the title of the page. It uses a regular expression to match the title, allowing for some flexibility in the expected value.

Note how similar this is to the Vitest tests we've written before. The main difference is that Playwright provides a `page` object that allows us to interact with the browser and the application.




{/* TODO
- https://playwright.dev/docs/test-fixtures incl. built-in like page
- https://playwright.dev/docs/browser-contexts
-  */}