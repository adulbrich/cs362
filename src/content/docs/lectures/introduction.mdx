---
title: Introduction
description: Explore software engineering beyond coding in CS362. Learn automated testing, CI/CD pipelines, and collaborative development practices to build reliable, production-ready software.
sidebar:
  order: 0
---

{/* TODO: review original notes */}

Welcome to CS 362, the second course in our software engineering series! In your earlier CS courses, you focused on sharpening your programming skills. Classes like CS 162 and CS 261 introduced general programming concepts, while others, such as CS 290 or CS 492, explored specific tools or languages. You've also delved into CS theory, providing a strong foundation. But here's the key takeaway: programming is just one part of creating great software.

## Beyond Programming: The Reality of Software Development

Let's start with a fundamental truth: coding is essential for software development. Without programming, software can't exist—simple enough, right? But here's the twist: being an exceptional programmer—someone who writes elegant, efficient code—isn't enough to guarantee high-quality software. This is where things get interesting.

The reality is that creating reliable, production-grade software requires more than just top-tier coding skills. Why? Because we're all human, and humans make mistakes. A lot of them.

Even the best developers write buggy code, mistype build commands, upload incorrect files, commit sensitive keys to public repositories, or accidentally overwrite a teammate's work. These aren't rare occurrences—they're part of being human. CS 362 is about acknowledging this reality. Once we accept that mistakes are inevitable, we can focus on building systems to mitigate their impact.

This becomes especially critical when developing software that people rely on—whether it's apps with millions of users or systems designed to run for years. That's the kind of development you'll face after college, and this course is designed to prepare you for it.

## What This Course Covers

CS 362 focuses on strategies and processes to reduce the impact of human errors on software users, particularly as projects grow in size and complexity. We'll dive into three essential areas every software engineer must master to deliver production-ready code:

1. Software Testing  
2. Process Automation (Continuous Integration and Delivery/Deployment)  
3. Collaborative Development on Shared Code  

This is a **technical** course, so expect to spend most of your time writing code, configuring tools, and working with systems like GitHub. Here's a breakdown of what you'll learn in each area.

### Software Testing: Catching Problems Before Users Do

Testing is one of the most effective ways to ensure your software behaves as expected. You may already test your code informally—running it manually, tweaking inputs, and checking outputs. That's a start, but in CS 362, we'll take it further with *formalized, automated testing*. This involves writing code to test your code.

Imagine creating a script that feeds specific inputs into your program under controlled conditions and verifies the results. That's automated testing in a nutshell. We'll explore three main types of testing, each with a unique focus:

- **Unit Testing**: Tests small, isolated pieces of code, like a single function. Does it return the correct value?  
- **Integration Testing**: Ensures multiple components of your software work together, such as two modules sharing data.  
- **End-to-End Testing**: Validates complete workflows, like a user signing up through your app's interface.  

For each type, we'll cover tools (e.g., testing frameworks), techniques (how to write effective tests), and best practices (what makes a test reliable). We'll also introduce *Test-Driven Development* (TDD), where you write tests before the code itself—a powerful approach for catching issues early.

### Continuous Integration and Delivery/Deployment: Automating Away Mistakes

Coding is just one part of software development. You also need to build, test, and deploy it—tasks often done manually by typing commands or moving files. Mistakes, like fat-fingering a command or uploading the wrong version, are common.

This is where *continuous integration and continuous delivery/deployment* (CI/CD) come in. CI/CD automates repetitive tasks, reducing human error. Here's how it works: you push code to a shared repository (e.g., GitHub), and a pipeline automatically builds it, runs tests, and either stages it for further checks or deploys it to users.

Imagine fixing a bug, pushing your changes, and having your code tested and live within minutes—all without manual intervention. That's CI/CD in action. In this course, you'll set up your own pipelines using GitHub, learning to automate builds, tests, and deployments. These skills are widely used in the industry.

### Working with Others: Collaboration Without Chaos

Most of your CS journey has likely involved solo coding assignments. If you've worked on a team project (like in CS 361), you know collaboration introduces new challenges. Suddenly, multiple people are contributing to the same codebase, and things can get messy.

Have you ever had a teammate misinterpret your code and break something? Or accidentally undo someone else's work? These issues arise when developers aren't aligned. To prevent this, teams use structured workflows. You may have encountered some in CS 361, but here, we'll focus on *code review*.

In code review, another developer reviews your changes before they are merged into the main codebase. They identify bugs, suggest improvements, and approve the changes when they're ready. We'll use GitHub for this—submitting changes via pull requests and reviewing them there. This process is standard in the industry.

Beyond catching errors, code review ensures knowledge is shared across the team. If only one person understands a piece of code, the team is at risk if that person leaves. Code review keeps everyone informed.

## Hands-On Learning

This course emphasizes practical, hands-on learning. You'll write tests, build CI/CD pipelines, submit code for review, and review your peers' work. The goal is to familiarize you with tools and practices you'll encounter in the industry, so you're job-ready.

There will be four assignments combining coding and tool setup, plus a final team project to bring everything together. No essays or quizzes—just technical, hands-on work.

We'll use JavaScript as the standard language. Why JavaScript? It's widely used, integrates well with testing and CI/CD tools, and you've likely encountered it before. If you're rusty, don't worry—our examples will use simple, clear syntax to help you get up to speed.

## Wrapping Up

CS 362 bridges the gap between coding as a student and engineering software as a professional. It's about acknowledging our imperfections and building systems to manage them. By the end of this course, you'll have the skills to test rigorously, automate confidently, and collaborate effectively. Let's get started!

## Additional Readings

- [What Is Software Engineering?](https://abseil.io/resources/swe-book/html/ch01.html) from Software Engineering at Google
